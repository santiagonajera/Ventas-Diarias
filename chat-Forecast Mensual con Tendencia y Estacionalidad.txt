### USER
genera un codigo de python para hacer el forecasting de un  grupo de datos, lo datos se encuentran en dias, pero quiero hacer la proyeccion mensual. para la proyeccion quiero que calcule la tendencia mensual y la estacionalidad, y con la combinacion de ambas genera el forecast de los 3 siguientes meses. El archivo con los datos e encuentra en

https://github.com/santiagonajera/Ventas-Diarias/blob/main/Ventas_diarias_restaurante.csv  

la estructura de los datos es la siguiente
Fecha	Pizza	Hamburguesa	Ensalada	Sushi
2023-01-01	91.0	55.0	50.0	40.0
2023-01-02	58.0	28.0	26.0	44.0
2023-01-03	76.0	43.0	41.0	54.0
2023-01-04	89.0	64.0	29.0	53.0
2023-01-05	68.0	77.0	30.0	52.0

### ASSISTANT
Te ayudo a crear un código de Python para hacer forecasting mensual considerando tendencia y estacionalidad. Aquí tienes la solución:

```python
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.holtwinters import ExponentialSmoothing
import warnings
warnings.filterwarnings('ignore')

# Configuración de estilo para las gráficas
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")

def load_and_prepare_data(url):
    """Cargar y preparar los datos"""
    # Cargar datos desde GitHub (usando el raw URL)
    raw_url = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob', '')
    df = pd.read_csv(raw_url)
    
    # Convertir la columna de fecha a datetime
    df['Fecha'] = pd.to_datetime(df['Fecha'])
    
    # Ordenar por fecha
    df = df.sort_values('Fecha').reset_index(drop=True)
    
    return df

def aggregate_to_monthly(df):
    """Convertir datos diarios a mensuales"""
    # Agrupar por mes y sumar las ventas
    df_monthly = df.groupby(df['Fecha'].dt.to_period('M')).agg({
        'Pizza': 'sum',
        'Hamburguesa': 'sum',
        'Ensalada': 'sum',
        'Sushi': 'sum'
    }).reset_index()
    
    # Convertir el período a fecha (primer día del mes)
    df_monthly['Fecha'] = df_monthly['Fecha'].dt.to_timestamp()
    
    return df_monthly

def analyze_seasonality_and_trend(df_monthly, product):
    """Analizar estacionalidad y tendencia para un producto"""
    # Crear serie temporal
    ts = df_monthly.set_index('Fecha')[product]
    
    # Descomposición de la serie temporal
    decomposition = seasonal_decompose(ts, model='additive', period=12)
    
    return decomposition

def forecast_next_3_months(df_monthly, product):
    """Generar forecast para los próximos 3 meses"""
    # Crear serie temporal
    ts = df_monthly.set_index('Fecha')[product]
    
    # Modelo de suavizamiento exponencial con tendencia y estacionalidad
    model = ExponentialSmoothing(
        ts,
        trend='add',
        seasonal='add',
        seasonal_periods=12,
        initialization_method='estimated'
    )
    
    # Ajustar el modelo
    fitted_model = model.fit()
    
    # Forecast para los próximos 3 meses
    forecast = fitted_model.forecast(steps=3)
    
    # Intervalos de confianza
    forecast_ci = fitted_model.conf_int(alpha=0.05)
    forecast_ci_next = forecast_ci.iloc[-3:]
    
    return forecast, forecast_ci_next, fitted_model

def create_forecast_dates(last_date, periods=3):
    """Crear fechas para el forecast"""
    forecast_dates = []
    current_date = last_date
    
    for i in range(periods):
        # Agregar un mes
        if current_date.month == 12:
            next_date = current_date.replace(year=current_date.year + 1, month=1, day=1)
        else:
            next_date = current_date.replace(month=current_date.month + 1, day=1)
        forecast_dates.append(next_date)
        current_date = next_date
    
    return forecast_dates

def plot_forecast_results(df_monthly, product, forecast, forecast_dates, decomposition):
    """Crear gráficas de los resultados"""
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    fig.suptitle(f'Análisis y Forecasting - {product}', fontsize=16, fontweight='bold')
    
    # 1. Serie original con forecast
    axes[0, 0].plot(df_monthly['Fecha'], df_monthly[product], marker='o', linewidth=2, label='Datos históricos')
    axes[0, 0].plot(forecast_dates, forecast, marker='s', linewidth=2, color='red', label='Forecast')
    axes[0, 0].set_title('Ventas Históricas y Forecast')
    axes[0, 0].set_xlabel('Fecha')
    axes[0, 0].set_ylabel('Ventas')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    
    # 2. Tendencia
    axes[0, 1].plot(decomposition.trend.index, decomposition.trend.values, linewidth=2, color='orange')
    axes[0, 1].set_title('Tendencia')
    axes[0, 1].set_xlabel('Fecha')
    axes[0, 1].set_ylabel('Tendencia')
    axes[0, 1].grid(True, alpha=0.3)
    
    # 3. Estacionalidad
    axes[1, 0].plot(decomposition.seasonal.index, decomposition.seasonal.values, linewidth=2, color='green')
    axes[1, 0].set_title('Componente Estacional')
    axes[1, 0].set_xlabel('Fecha')
    axes[1, 0].set_ylabel('Estacionalidad')
    axes[1, 0].grid(True, alpha=0.3)
    
    # 4. Residuos
    axes[1, 1].plot(decomposition.resid.index, decomposition.resid.values, marker='o', linewidth=1, color='purple')
    axes[1, 1].set_title('Residuos')
    axes[1, 1].set_xlabel('Fecha')
    axes[1, 1].set_ylabel('Residuos')
    axes[1, 1].grid(True, alpha=0.3)
    axes[1, 1].axhline(y=0, color='black', linestyle='--', alpha=0.7)
    
    plt.tight_layout()
    plt.show()

def main():
    # URL del archivo
    url = "https://github.com/santiagonajera/Ventas-Diarias/blob/main/Ventas_diarias_restaurante.csv"
    
    try:
        # Cargar y preparar datos
        print("Cargando datos...")
        df = load_and_prepare_data(url)
        print(f"Datos cargados: {len(df)} registros")
        
        # Convertir a datos mensuales
        print("Agregando datos a nivel mensual...")
        df_monthly = aggregate_to_monthly(df)
        print(f"Datos mensuales: {len(df_monthly)} meses")
        
        # Productos a analizar
        products = ['Pizza', 'Hamburguesa', 'Ensalada', 'Sushi']
        
        # Diccionario para almacenar resultados
        forecast_results = {}
        
        # Procesar cada producto
        for product in products:
            print(f"\nAnalizando {product}...")
            
            # Análisis de estacionalidad y tendencia
            decomposition = analyze_seasonality_and_trend(df_monthly, product)
            
            # Forecast para los próximos 3 meses
            forecast, forecast_ci, model = forecast_next_3_months(df_monthly, product)
            
            # Crear fechas para el forecast
            last_date = df_monthly['Fecha'].iloc[-1]
            forecast_dates = create_forecast_dates(last_date)
            
            # Almacenar resultados
            forecast_results[product] = {
                'forecast': forecast,
                'forecast_dates': forecast_dates,
                'confidence_intervals': forecast_ci,
                'decomposition': decomposition,
                'model': model
            }
            
            # Mostrar resultados numéricos
            print(f"Forecast para {product} (próximos 3 meses):")
            for i, (date, value) in enumerate(zip(forecast_dates, forecast)):
                print(f"  {date.strftime('%Y-%m')}: {value:.1f}")
            
            # Crear gráficas
            plot_forecast_results(df_monthly, product, forecast, forecast_dates, decomposition)
        
        # Crear resumen de forecasts
        print("\n" + "="*60)
        print("RESUMEN DE FORECASTS - PRÓXIMOS 3 MESES")
        print("="*60)
        
        # Crear DataFrame con todos los forecasts
        summary_data = []
        for product in products:
            forecast = forecast_results[product]['forecast']
            forecast_dates = forecast_results[product]['forecast_dates']
            
            for i, (date, value) in enumerate(zip(forecast_dates, forecast)):
                summary_data.append({
                    'Producto': product,
                    'Mes': date.strftime('%Y-%m'),
                    'Forecast': round(value, 1)
                })
        
        summary_df = pd.DataFrame(summary_data)
        summary_pivot = summary_df.pivot(index='Mes', columns='Producto', values='Forecast')
        print(summary_pivot)
        
        # Guardar resultados en CSV
        summary_df.to_csv('forecast_resultados.csv', index=False)
        print(f"\nResultados guardados en 'forecast_resultados.csv'")
        
        # Mostrar estadísticas descriptivas
        print("\n" + "="*60)
        print("ESTADÍSTICAS DESCRIPTIVAS - DATOS MENSUALES")
        print("="*60)
        monthly_stats = df_monthly[products].describe()
        print(monthly_stats.round(2))
        
    except Exception as e:
        print(f"Error: {str(e)}")
        print("Asegúrate de tener conexión a internet y que el archivo esté disponible en la URL proporcionada.")

if __name__ == "__main__":
    main()
```

Este código realiza las siguientes funciones:

## Características principales:

1. **Carga de datos**: Descarga el archivo CSV desde GitHub
2. **Agregación temporal**: Convierte datos diarios a mensuales sumando las ventas
3. **Análisis de componentes**: 
   - Tendencia usando descomposición aditiva
   - Estacionalidad mensual (patrón anual)
   - Componente residual

4. **Modelo de forecasting**: 
   - Usa Holt-Winters Exponential Smoothing
   - Considera tanto tendencia como estacionalidad
   - Genera forecast para los próximos 3 meses

5. **Visualización**: 
   - Gráficas de series temporales
   - Componentes de tendencia, estacionalidad y residuos
   - Intervalos de confianza

6. **Resultados**: 
   - Tabla resumen de forecasts
   - Estadísticas descriptivas
   - Exportación a CSV

## Requisitos:

```bash
pip install pandas numpy matplotlib seaborn statsmodels
```

## Salida esperada:

El código generará:
- 4 gráficas (una por producto) con 4 subplots cada una
- Tabla resumen con los forecasts de los 3 meses siguientes
- Archivo CSV con todos los resultados
- Estadísticas descriptivas de los datos mensuales

¿Te gustaría que modifique algún aspecto específico del código o que agregue alguna funcionalidad adicional?

### USER
genero un error

Cargando datos...
Datos cargados: 731 registros
Agregando datos a nivel mensual...
Datos mensuales: 24 meses

Analizando Pizza...
Error: 'HoltWintersResults' object has no attribute 'conf_int'
Asegúrate de tener conexión a internet y que el archivo esté disponible en la URL proporcionada.

### ASSISTANT
Tienes razón, hay un error con el método `conf_int` en la versión del modelo que estamos usando. Vamos a corregir el código para que funcione correctamente:

```python
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.holtwinters import ExponentialSmoothing
import warnings
warnings.filterwarnings('ignore')

# Configuración de estilo para las gráficas
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")

def load_and_prepare_data(filename):
    """Cargar y preparar los datos desde el archivo local"""
    # Cargar datos
    df = pd.read_csv(filename)
    
    # Convertir la columna de fecha a datetime
    df['Fecha'] = pd.to_datetime(df['Fecha'])
    
    # Ordenar por fecha
    df = df.sort_values('Fecha').reset_index(drop=True)
    
    return df

def aggregate_to_monthly(df):
    """Convertir datos diarios a mensuales"""
    # Agrupar por mes y sumar las ventas
    df_monthly = df.groupby(df['Fecha'].dt.to_period('M')).agg({
        'Pizza': 'sum',
        'Hamburguesa': 'sum',
        'Ensalada': 'sum',
        'Sushi': 'sum'
    }).reset_index()
    
    # Convertir el período a fecha (primer día del mes)
    df_monthly['Fecha'] = df_monthly['Fecha'].dt.to_timestamp()
    
    return df_monthly

def analyze_seasonality_and_trend(df_monthly, product):
    """Analizar estacionalidad y tendencia para un producto"""
    # Crear serie temporal
    ts = df_monthly.set_index('Fecha')[product]
    
    # Descomposición de la serie temporal
    decomposition = seasonal_decompose(ts, model='additive', period=12)
    
    return decomposition

def forecast_next_3_months(df_monthly, product):
    """Generar forecast para los próximos 3 meses"""
    # Crear serie temporal
    ts = df_monthly.set_index('Fecha')[product]
    
    # Modelo de suavizamiento exponencial con tendencia y estacionalidad
    model = ExponentialSmoothing(
        ts,
        trend='add',
        seasonal='add',
        seasonal_periods=12,
        initialization_method='estimated'
    )
    
    # Ajustar el modelo
    fitted_model = model.fit()
    
    # Forecast para los próximos 3 meses
    forecast = fitted_model.forecast(steps=3)
    
    return forecast, fitted_model

def create_forecast_dates(last_date, periods=3):
    """Crear fechas para el forecast"""
    forecast_dates = []
    current_date = last_date
    
    for i in range(periods):
        # Agregar un mes
        if current_date.month == 12:
            next_date = current_date.replace(year=current_date.year + 1, month=1, day=1)
        else:
            next_date = current_date.replace(month=current_date.month + 1, day=1)
        forecast_dates.append(next_date)
        current_date = next_date
    
    return forecast_dates

def plot_forecast_results(df_monthly, product, forecast, forecast_dates, decomposition):
    """Crear gráficas de los resultados"""
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    fig.suptitle(f'Análisis y Forecasting - {product}', fontsize=16, fontweight='bold')
    
    # 1. Serie original con forecast
    axes[0, 0].plot(df_monthly['Fecha'], df_monthly[product], marker='o', linewidth=2, label='Datos históricos')
    axes[0, 0].plot(forecast_dates, forecast, marker='s', linewidth=2, color='red', label='Forecast')
    axes[0, 0].set_title('Ventas Históricas y Forecast')
    axes[0, 0].set_xlabel('Fecha')
    axes[0, 0].set_ylabel('Ventas')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    
    # 2. Tendencia
    axes[0, 1].plot(decomposition.trend.index, decomposition.trend.values, linewidth=2, color='orange')
    axes[0, 1].set_title('Tendencia')
    axes[0, 1].set_xlabel('Fecha')
    axes[0, 1].set_ylabel('Tendencia')
    axes[0, 1].grid(True, alpha=0.3)
    
    # 3. Estacionalidad
    axes[1, 0].plot(decomposition.seasonal.index, decomposition.seasonal.values, linewidth=2, color='green')
    axes[1, 0].set_title('Componente Estacional')
    axes[1, 0].set_xlabel('Fecha')
    axes[1, 0].set_ylabel('Estacionalidad')
    axes[1, 0].grid(True, alpha=0.3)
    
    # 4. Residuos
    axes[1, 1].plot(decomposition.resid.index, decomposition.resid.values, marker='o', linewidth=1, color='purple')
    axes[1, 1].set_title('Residuos')
    axes[1, 1].set_xlabel('Fecha')
    axes[1, 1].set_ylabel('Residuos')
    axes[1, 1].grid(True, alpha=0.3)
    axes[1, 1].axhline(y=0, color='black', linestyle='--', alpha=0.7)
    
    plt.tight_layout()
    plt.show()

def main():
    # Nombre del archivo (ajusta según el nombre real de tu archivo)
    filename = "Ventas_diarias_restaurante.csv"
    
    try:
        # Cargar y preparar datos
        print("Cargando datos...")
        df = load_and_prepare_data(filename)
        print(f"Datos cargados: {len(df)} registros")
        
        # Convertir a datos mensuales
        print("Agregando datos a nivel mensual...")
        df_monthly = aggregate_to_monthly(df)
        print(f"Datos mensuales: {len(df_monthly)} meses")
        
        # Productos a analizar
        products = ['Pizza', 'Hamburguesa', 'Ensalada', 'Sushi']
        
        # Diccionario para almacenar resultados
        forecast_results = {}
        
        # Procesar cada producto
        for product in products:
            print(f"\nAnalizando {product}...")
            
            # Análisis de estacionalidad y tendencia
            decomposition = analyze_seasonality_and_trend(df_monthly, product)
            
            # Forecast para los próximos 3 meses
            forecast, model = forecast_next_3_months(df_monthly, product)
            
            # Crear fechas para el forecast
            last_date = df_monthly['Fecha'].iloc[-1]
            forecast_dates = create_forecast_dates(last_date)
            
            # Almacenar resultados
            forecast_results[product] = {
                'forecast': forecast,
                'forecast_dates': forecast_dates,
                'decomposition': decomposition,
                'model': model
            }
            
            # Mostrar resultados numéricos
            print(f"Forecast para {product} (próximos 3 meses):")
            for i, (date, value) in enumerate(zip(forecast_dates, forecast)):
                print(f"  {date.strftime('%Y-%m')}: {value:.1f}")
            
            # Crear gráficas
            plot_forecast_results(df_monthly, product, forecast, forecast_dates, decomposition)
        
        # Crear resumen de forecasts
        print("\n" + "="*60)
        print("RESUMEN DE FORECASTS - PRÓXIMOS 3 MESES")
        print("="*60)
        
        # Crear DataFrame con todos los forecasts
        summary_data = []
        for product in products:
            forecast = forecast_results[product]['forecast']
            forecast_dates = forecast_results[product]['forecast_dates']
            
            for i, (date, value) in enumerate(zip(forecast_dates, forecast)):
                summary_data.append({
                    'Producto': product,
                    'Mes': date.strftime('%Y-%m'),
                    'Forecast': round(value, 1)
                })
        
        summary_df = pd.DataFrame(summary_data)
        summary_pivot = summary_df.pivot(index='Mes', columns='Producto', values='Forecast')
        print(summary_pivot)
        
        # Guardar resultados en CSV
        summary_df.to_csv('forecast_resultados.csv', index=False)
        print(f"\nResultados guardados en 'forecast_resultados.csv'")
        
        # Mostrar estadísticas descriptivas
        print("\n" + "="*60)
        print("ESTADÍSTICAS DESCRIPTIVAS - DATOS MENSUALES")
        print("="*60)
        monthly_stats = df_monthly[products].describe()
        print(monthly_stats.round(2))
        
    except Exception as e:
        print(f"Error: {str(e)}")
        print("Asegúrate de que el archivo esté en el directorio correcto.")

if __name__ == "__main__":
    main()
```

Los cambios principales que hice:

1. **Eliminé el uso de `conf_int()`**: Este método no está disponible en todas las versiones de statsmodels, por eso daba error.

2. **Modifiqué la función de carga**: Ahora carga el archivo localmente en lugar de desde GitHub.

3. **Simplifiqué la función de forecast**: Eliminé la parte que intentaba obtener intervalos de confianza.

4. **Actualicé el mensaje de error**: Para que sea más claro sobre el problema con el archivo local.

Para usar este código:

1. Asegúrate de que el archivo `Ventas_diarias_restaurante.csv` esté en el mismo directorio que el script de Python.
2. Ejecuta el script.

El código te mostrará:
- Las gráficas de análisis para cada producto
- Los valores de forecast para los próximos 3 meses
- Una tabla resumen con todos los forecasts
- Estadísticas descriptivas de los datos mensuales
- Guardará los resultados en un archivo `forecast_resultados.csv`

¿Te gustaría que agregue alguna funcionalidad adicional como intervalos de confianza o métricas de error?

### USER
recuerda que el archivo esta en el url https://github.com/santiagonajera/Ventas-Diarias/blob/main/Ventas_diarias_restaurante.csv  

### ASSISTANT
Tienes razón, gracias por la aclaración. Aquí tienes el código actualizado que carga el archivo directamente desde la URL de GitHub:

```python
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.holtwinters import ExponentialSmoothing
import warnings
warnings.filterwarnings('ignore')

# Configuración de estilo para las gráficas
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")

def load_and_prepare_data(url):
    """Cargar y preparar los datos desde GitHub"""
    # Convertir URL de GitHub a URL raw
    raw_url = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob', '')
    
    # Cargar datos
    df = pd.read_csv(raw_url)
    
    # Convertir la columna de fecha a datetime
    df['Fecha'] = pd.to_datetime(df['Fecha'])
    
    # Ordenar por fecha
    df = df.sort_values('Fecha').reset_index(drop=True)
    
    return df

def aggregate_to_monthly(df):
    """Convertir datos diarios a mensuales"""
    # Agrupar por mes y sumar las ventas
    df_monthly = df.groupby(df['Fecha'].dt.to_period('M')).agg({
        'Pizza': 'sum',
        'Hamburguesa': 'sum',
        'Ensalada': 'sum',
        'Sushi': 'sum'
    }).reset_index()
    
    # Convertir el período a fecha (primer día del mes)
    df_monthly['Fecha'] = df_monthly['Fecha'].dt.to_timestamp()
    
    return df_monthly

def analyze_seasonality_and_trend(df_monthly, product):
    """Analizar estacionalidad y tendencia para un producto"""
    # Crear serie temporal
    ts = df_monthly.set_index('Fecha')[product]
    
    # Descomposición de la serie temporal
    decomposition = seasonal_decompose(ts, model='additive', period=12)
    
    return decomposition

def forecast_next_3_months(df_monthly, product):
    """Generar forecast para los próximos 3 meses"""
    # Crear serie temporal
    ts = df_monthly.set_index('Fecha')[product]
    
    # Modelo de suavizamiento exponencial con tendencia y estacionalidad
    model = ExponentialSmoothing(
        ts,
        trend='add',
        seasonal='add',
        seasonal_periods=12,
        initialization_method='estimated'
    )
    
    # Ajustar el modelo
    fitted_model = model.fit()
    
    # Forecast para los próximos 3 meses
    forecast = fitted_model.forecast(steps=3)
    
    return forecast, fitted_model

def create_forecast_dates(last_date, periods=3):
    """Crear fechas para el forecast"""
    forecast_dates = []
    current_date = last_date
    
    for i in range(periods):
        # Agregar un mes
        if current_date.month == 12:
            next_date = current_date.replace(year=current_date.year + 1, month=1, day=1)
        else:
            next_date = current_date.replace(month=current_date.month + 1, day=1)
        forecast_dates.append(next_date)
        current_date = next_date
    
    return forecast_dates

def plot_forecast_results(df_monthly, product, forecast, forecast_dates, decomposition):
    """Crear gráficas de los resultados"""
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    fig.suptitle(f'Análisis y Forecasting - {product}', fontsize=16, fontweight='bold')
    
    # 1. Serie original con forecast
    axes[0, 0].plot(df_monthly['Fecha'], df_monthly[product], marker='o', linewidth=2, label='Datos históricos')
    axes[0, 0].plot(forecast_dates, forecast, marker='s', linewidth=2, color='red', label='Forecast')
    axes[0, 0].set_title('Ventas Históricas y Forecast')
    axes[0, 0].set_xlabel('Fecha')
    axes[0, 0].set_ylabel('Ventas')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    
    # 2. Tendencia
    axes[0, 1].plot(decomposition.trend.index, decomposition.trend.values, linewidth=2, color='orange')
    axes[0, 1].set_title('Tendencia')
    axes[0, 1].set_xlabel('Fecha')
    axes[0, 1].set_ylabel('Tendencia')
    axes[0, 1].grid(True, alpha=0.3)
    
    # 3. Estacionalidad
    axes[1, 0].plot(decomposition.seasonal.index, decomposition.seasonal.values, linewidth=2, color='green')
    axes[1, 0].set_title('Componente Estacional')
    axes[1, 0].set_xlabel('Fecha')
    axes[1, 0].set_ylabel('Estacionalidad')
    axes[1, 0].grid(True, alpha=0.3)
    
    # 4. Residuos
    axes[1, 1].plot(decomposition.resid.index, decomposition.resid.values, marker='o', linewidth=1, color='purple')
    axes[1, 1].set_title('Residuos')
    axes[1, 1].set_xlabel('Fecha')
    axes[1, 1].set_ylabel('Residuos')
    axes[1, 1].grid(True, alpha=0.3)
    axes[1, 1].axhline(y=0, color='black', linestyle='--', alpha=0.7)
    
    plt.tight_layout()
    plt.show()

def main():
    # URL del archivo en GitHub
    url = "https://github.com/santiagonajera/Ventas-Diarias/blob/main/Ventas_diarias_restaurante.csv"
    
    try:
        # Cargar y preparar datos
        print("Cargando datos desde GitHub...")
        df = load_and_prepare_data(url)
        print(f"Datos cargados: {len(df)} registros")
        
        # Convertir a datos mensuales
        print("Agregando datos a nivel mensual...")
        df_monthly = aggregate_to_monthly(df)
        print(f"Datos mensuales: {len(df_monthly)} meses")
        
        # Productos a analizar
        products = ['Pizza', 'Hamburguesa', 'Ensalada', 'Sushi']
        
        # Diccionario para almacenar resultados
        forecast_results = {}
        
        # Procesar cada producto
        for product in products:
            print(f"\nAnalizando {product}...")
            
            # Análisis de estacionalidad y tendencia
            decomposition = analyze_seasonality_and_trend(df_monthly, product)
            
            # Forecast para los próximos 3 meses
            forecast, model = forecast_next_3_months(df_monthly, product)
            
            # Crear fechas para el forecast
            last_date = df_monthly['Fecha'].iloc[-1]
            forecast_dates = create_forecast_dates(last_date)
            
            # Almacenar resultados
            forecast_results[product] = {
                'forecast': forecast,
                'forecast_dates': forecast_dates,
                'decomposition': decomposition,
                'model': model
            }
            
            # Mostrar resultados numéricos
            print(f"Forecast para {product} (próximos 3 meses):")
            for i, (date, value) in enumerate(zip(forecast_dates, forecast)):
                print(f"  {date.strftime('%Y-%m')}: {value:.1f}")
            
            # Crear gráficas
            plot_forecast_results(df_monthly, product, forecast, forecast_dates, decomposition)
        
        # Crear resumen de forecasts
        print("\n" + "="*60)
        print("RESUMEN DE FORECASTS - PRÓXIMOS 3 MESES")
        print("="*60)
        
        # Crear DataFrame con todos los forecasts
        summary_data = []
        for product in products:
            forecast = forecast_results[product]['forecast']
            forecast_dates = forecast_results[product]['forecast_dates']
            
            for i, (date, value) in enumerate(zip(forecast_dates, forecast)):
                summary_data.append({
                    'Producto': product,
                    'Mes': date.strftime('%Y-%m'),
                    'Forecast': round(value, 1)
                })
        
        summary_df = pd.DataFrame(summary_data)
        summary_pivot = summary_df.pivot(index='Mes', columns='Producto', values='Forecast')
        print(summary_pivot)
        
        # Guardar resultados en CSV
        summary_df.to_csv('forecast_resultados.csv', index=False)
        print(f"\nResultados guardados en 'forecast_resultados.csv'")
        
        # Mostrar estadísticas descriptivas
        print("\n" + "="*60)
        print("ESTADÍSTICAS DESCRIPTIVAS - DATOS MENSUALES")
        print("="*60)
        monthly_stats = df_monthly[products].describe()
        print(monthly_stats.round(2))
        
    except Exception as e:
        print(f"Error: {str(e)}")
        print("Asegúrate de tener conexión a internet y que el archivo esté disponible en la URL proporcionada.")

if __name__ == "__main__":
    main()
```

Este código:

1. **Carga datos directamente desde GitHub** usando la URL que proporcionaste
2. **Convierte datos diarios a mensuales** sumando las ventas de cada mes
3. **Analiza tendencia y estacionalidad** usando descomposición aditiva
4. **Genera forecast para 3 meses** usando Holt-Winters Exponential Smoothing
5. **Muestra resultados gráficos y numéricos** para cada producto

El código creará:
- Gráficas de análisis para cada producto
- Tabla resumen con forecasts de los próximos 3 meses
- Archivo CSV con los resultados
- Estadísticas descriptivas de los datos mensuales

Ejecuta el script y te mostrará los resultados para Pizza, Hamburguesa, Ensalada y Sushi.

### USER
ahora, con los mismos datos quiero las proyecciones diarias de los proximos 15 dias. para esto utiliza la libreria prophet, revisa si esta a instalada, caso contrario instala la libreria. todo genera en un solo codigo

### ASSISTANT
```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# Intentar importar Prophet, si no está instalada, instalarla
try:
    from prophet import Prophet
    print("Prophet ya está instalada")
except ImportError:
    print("Instalando Prophet...")
    import subprocess
    import sys
    subprocess.check_call([sys.executable, "-m", "pip", "install", "prophet"])
    from prophet import Prophet
    print("Prophet instalada correctamente")

# Configuración de estilo para las gráficas
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")

def load_and_prepare_data():
    """Cargar y preparar los datos desde el archivo local"""
    # Cargar datos
    df = pd.read_csv('Ventas_diarias_restaurante.csv')
    
    # Convertir la columna de fecha a datetime
    df['Fecha'] = pd.to_datetime(df['Fecha'])
    
    # Ordenar por fecha
    df = df.sort_values('Fecha').reset_index(drop=True)
    
    return df

def prepare_data_for_prophet(df, product):
    """Preparar datos para Prophet"""
    # Seleccionar solo las columnas necesarias
    data = df[['Fecha', product]].copy()
    
    # Renombrar columnas según lo requerido por Prophet
    data = data.rename(columns={'Fecha': 'ds', product: 'y'})
    
    return data

def forecast_next_15_days(df_prophet, product_name):
    """Generar forecast para los próximos 15 días usando Prophet"""
    
    # Crear y configurar el modelo Prophet
    model = Prophet(
        yearly_seasonality=True,
        weekly_seasonality=True,
        daily_seasonality=False,
        seasonality_mode='additive'
    )
    
    # Ajustar el modelo
    model.fit(df_prophet)
    
    # Crear dataframe para future predictions (próximos 15 días)
    future = model.make_future_dataframe(periods=15)
    
    # Hacer las predicciones
    forecast = model.predict(future)
    
    return model, forecast

def plot_prophet_forecast(model, forecast, product_name, df_prophet):
    """Crear gráfica de forecast de Prophet"""
    fig = model.plot(forecast, figsize=(12, 6))
    plt.title(f'Forecast de {product_name} - Próximos 15 días', fontsize=14, fontweight='bold')
    plt.xlabel('Fecha')
    plt.ylabel('Ventas')
    plt.grid(True, alpha=0.3)
    plt.show()
    
    # Gráfica de componentes
    fig2 = model.plot_components(forecast, figsize=(12, 8))
    plt.show()

def main():
    try:
        # Cargar y preparar datos
        print("Cargando datos...")
        df = load_and_prepare_data()
        print(f"Datos cargados: {len(df)} registros")
        print(f"Rango de fechas: {df['Fecha'].min()} a {df['Fecha'].max()}")
        
        # Productos a analizar
        products = ['Pizza', 'Hamburguesa', 'Ensalada', 'Sushi']
        
        # Diccionario para almacenar resultados
        forecast_results = {}
        
        # Procesar cada producto
        for product in products:
            print(f"\nAnalizando {product}...")
            
            # Preparar datos para Prophet
            df_prophet = prepare_data_for_prophet(df, product)
            
            # Forecast para los próximos 15 días
            model, forecast = forecast_next_15_days(df_prophet, product)
            
            # Almacenar resultados
            forecast_results[product] = {
                'model': model,
                'forecast': forecast,
                'df_prophet': df_prophet
            }
            
            # Mostrar resultados numéricos para los próximos 15 días
            print(f"Forecast para {product} (próximos 15 días):")
            future_forecast = forecast.tail(15)[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].copy()
            future_forecast['ds'] = pd.to_datetime(future_forecast['ds'])
            future_forecast = future_forecast.round(1)
            
            for idx, row in future_forecast.iterrows():
                print(f"  {row['ds'].strftime('%Y-%m-%d')}: {row['yhat']:.1f} "
                      f"(IC: {row['yhat_lower']:.1f} - {row['yhat_upper']:.1f})")
            
            # Crear gráficas
            plot_prophet_forecast(model, forecast, product, df_prophet)
        
        # Crear resumen de forecasts
        print("\n" + "="*80)
        print("RESUMEN DE FORECASTS - PRÓXIMOS 15 DÍAS")
        print("="*80)
        
        # Crear DataFrame con todos los forecasts futuros
        summary_data = []
        for product in products:
            forecast = forecast_results[product]['forecast']
            future_forecast = forecast.tail(15)[['ds', 'yhat']].copy()
            future_forecast['Producto'] = product
            future_forecast = future_forecast.rename(columns={'ds': 'Fecha', 'yhat': 'Forecast'})
            summary_data.append(future_forecast)
        
        # Combinar todos los resultados
        summary_df = pd.concat(summary_data, ignore_index=True)
        summary_pivot = summary_df.pivot(index='Fecha', columns='Producto', values='Forecast')
        summary_pivot = summary_pivot.round(1)
        print(summary_pivot)
        
        # Guardar resultados en CSV
        summary_df.to_csv('forecast_15_dias_resultados.csv', index=False)
        print(f"\nResultados guardados en 'forecast_15_dias_resultados.csv'")
        
        # Mostrar estadísticas descriptivas
        print("\n" + "="*60)
        print("ESTADÍSTICAS DESCRIPTIVAS - DATOS DIARIOS")
        print("="*60)
        daily_stats = df[products].describe()
        print(daily_stats.round(2))
        
    except Exception as e:
        print(f"Error: {str(e)}")
        print("Asegúrate de que el archivo 'Ventas_diarias_restaurante.csv' esté en el directorio correcto.")

if __name__ == "__main__":
    main()
```

Este código realiza lo siguiente:

1. **Verifica e instala Prophet**: Si no está instalada, la instala automáticamente
2. **Carga los datos**: Lee el archivo CSV local
3. **Prepara datos para Prophet**: Formatea los datos según los requisitos de Prophet
4. **Genera forecast diario**: Crea predicciones para los próximos 15 días
5. **Incluye estacionalidad**: 
   - Estacionalidad anual (yearly_seasonality=True)
   - Estacionalidad semanal (weekly_seasonality=True)
6. **Visualización**: 
   - Gráficas de forecast con intervalos de confianza
   - Gráficas de componentes (tendencia, estacionalidad)
7. **Resultados**: 
   - Tabla resumen con forecasts de 15 días
   - Exportación a CSV
   - Estadísticas descriptivas

El código generará:
- Gráficas individuales para cada producto
- Una tabla resumen con los forecasts de los próximos 15 días
- Intervalos de confianza para cada predicción
- Archivo CSV con todos los resultados

Para ejecutarlo, asegúrate de tener el archivo `Ventas_diarias_restaurante.csv` en el mismo directorio que el script.

### USER
genero un error, recuerda que el archivo esta

https://github.com/santiagonajera/Ventas-Diarias/blob/main/Ventas_diarias_restaurante.csv  

ERROR
Prophet ya está instalada
Cargando datos...
Error: [Errno 2] No such file or directory: 'Ventas_diarias_restaurante.csv'
Asegúrate de que el archivo 'Ventas_diarias_restaurante.csv' esté en el directorio correcto.


### ASSISTANT
Tienes razón, el error es porque el código está buscando el archivo localmente en lugar de cargarlo desde la URL de GitHub. Aquí tienes el código corregido que carga los datos directamente desde GitHub:

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# Intentar importar Prophet, si no está instalada, instalarla
try:
    from prophet import Prophet
    print("Prophet ya está instalada")
except ImportError:
    print("Instalando Prophet...")
    import subprocess
    import sys
    subprocess.check_call([sys.executable, "-m", "pip", "install", "prophet"])
    from prophet import Prophet
    print("Prophet instalada correctamente")

# Configuración de estilo para las gráficas
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")

def load_and_prepare_data():
    """Cargar y preparar los datos desde GitHub"""
    # URL del archivo en GitHub
    url = "https://github.com/santiagonajera/Ventas-Diarias/blob/main/Ventas_diarias_restaurante.csv"
    
    # Convertir URL de GitHub a URL raw
    raw_url = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob', '')
    
    # Cargar datos desde la URL
    df = pd.read_csv(raw_url)
    
    # Convertir la columna de fecha a datetime
    df['Fecha'] = pd.to_datetime(df['Fecha'])
    
    # Ordenar por fecha
    df = df.sort_values('Fecha').reset_index(drop=True)
    
    return df

def prepare_data_for_prophet(df, product):
    """Preparar datos para Prophet"""
    # Seleccionar solo las columnas necesarias
    data = df[['Fecha', product]].copy()
    
    # Renombrar columnas según lo requerido por Prophet
    data = data.rename(columns={'Fecha': 'ds', product: 'y'})
    
    return data

def forecast_next_15_days(df_prophet, product_name):
    """Generar forecast para los próximos 15 días usando Prophet"""
    
    # Crear y configurar el modelo Prophet
    model = Prophet(
        yearly_seasonality=True,
        weekly_seasonality=True,
        daily_seasonality=False,
        seasonality_mode='additive'
    )
    
    # Ajustar el modelo
    model.fit(df_prophet)
    
    # Crear dataframe para future predictions (próximos 15 días)
    future = model.make_future_dataframe(periods=15)
    
    # Hacer las predicciones
    forecast = model.predict(future)
    
    return model, forecast

def plot_prophet_forecast(model, forecast, product_name, df_prophet):
    """Crear gráfica de forecast de Prophet"""
    fig = model.plot(forecast, figsize=(12, 6))
    plt.title(f'Forecast de {product_name} - Próximos 15 días', fontsize=14, fontweight='bold')
    plt.xlabel('Fecha')
    plt.ylabel('Ventas')
    plt.grid(True, alpha=0.3)
    plt.show()
    
    # Gráfica de componentes
    fig2 = model.plot_components(forecast, figsize=(12, 8))
    plt.show()

def main():
    try:
        # Cargar y preparar datos
        print("Cargando datos desde GitHub...")
        df = load_and_prepare_data()
        print(f"Datos cargados: {len(df)} registros")
        print(f"Rango de fechas: {df['Fecha'].min()} a {df['Fecha'].max()}")
        
        # Productos a analizar
        products = ['Pizza', 'Hamburguesa', 'Ensalada', 'Sushi']
        
        # Diccionario para almacenar resultados
        forecast_results = {}
        
        # Procesar cada producto
        for product in products:
            print(f"\nAnalizando {product}...")
            
            # Preparar datos para Prophet
            df_prophet = prepare_data_for_prophet(df, product)
            
            # Forecast para los próximos 15 días
            model, forecast = forecast_next_15_days(df_prophet, product)
            
            # Almacenar resultados
            forecast_results[product] = {
                'model': model,
                'forecast': forecast,
                'df_prophet': df_prophet
            }
            
            # Mostrar resultados numéricos para los próximos 15 días
            print(f"Forecast para {product} (próximos 15 días):")
            future_forecast = forecast.tail(15)[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].copy()
            future_forecast['ds'] = pd.to_datetime(future_forecast['ds'])
            future_forecast = future_forecast.round(1)
            
            for idx, row in future_forecast.iterrows():
                print(f"  {row['ds'].strftime('%Y-%m-%d')}: {row['yhat']:.1f} "
                      f"(IC: {row['yhat_lower']:.1f} - {row['yhat_upper']:.1f})")
            
            # Crear gráficas
            plot_prophet_forecast(model, forecast, product, df_prophet)
        
        # Crear resumen de forecasts
        print("\n" + "="*80)
        print("RESUMEN DE FORECASTS - PRÓXIMOS 15 DÍAS")
        print("="*80)
        
        # Crear DataFrame con todos los forecasts futuros
        summary_data = []
        for product in products:
            forecast = forecast_results[product]['forecast']
            future_forecast = forecast.tail(15)[['ds', 'yhat']].copy()
            future_forecast['Producto'] = product
            future_forecast = future_forecast.rename(columns={'ds': 'Fecha', 'yhat': 'Forecast'})
            summary_data.append(future_forecast)
        
        # Combinar todos los resultados
        summary_df = pd.concat(summary_data, ignore_index=True)
        summary_pivot = summary_df.pivot(index='Fecha', columns='Producto', values='Forecast')
        summary_pivot = summary_pivot.round(1)
        print(summary_pivot)
        
        # Guardar resultados en CSV
        summary_df.to_csv('forecast_15_dias_resultados.csv', index=False)
        print(f"\nResultados guardados en 'forecast_15_dias_resultados.csv'")
        
        # Mostrar estadísticas descriptivas
        print("\n" + "="*60)
        print("ESTADÍSTICAS DESCRIPTIVAS - DATOS DIARIOS")
        print("="*60)
        daily_stats = df[products].describe()
        print(daily_stats.round(2))
        
    except Exception as e:
        print(f"Error: {str(e)}")
        print("Asegúrate de tener conexión a internet y que el archivo esté disponible en la URL proporcionada.")

if __name__ == "__main__":
    main()
```

Este código corregido:

1. **Carga datos directamente desde GitHub** usando la URL proporcionada
2. **Convierte la URL a formato raw** para poder acceder al contenido del archivo
3. **Realiza forecasting diario** para los próximos 15 días usando Prophet
4. **Incluye estacionalidad semanal y anual** como lo requiere Prophet
5. **Muestra intervalos de confianza** para las predicciones
6. **Genera gráficas y tablas resumen** de los resultados

El código generará:
- Gráficas individuales para cada producto con sus forecasts
- Gráficas de componentes (tendencia, estacionalidad)
- Tabla resumen con los forecasts de los próximos 15 días
- Archivo CSV con todos los resultados
- Estadísticas descriptivas de los datos históricos